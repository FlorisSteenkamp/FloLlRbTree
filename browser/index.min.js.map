{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloLlRbTree","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","isRed","node","color","Color","RED","removeFromArray","elem","arr","index","indexOf","splice","rotate","dir","h","otherDir","Dir","LEFT","RIGHT","x","parent","removeMin","moveRedLeft","fixUp","flipColor","BLACK","flipColors","moveRedRight","Node","data","asArray","LlRbTree","compare","datas","replaceDups","getMinNode","getMinOrMaxNode","getMaxNode","tree","setComparator","root","_i","datas_1","insert","prototype","b","isEmpty","find","c","toArrayInOrder","nodes","push","undefined","remove","all","min","findBounds","bounds","findBoundsExcl","findAllInOrder","max"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloLlRbTree = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\"use strict\";\r\n/*\r\n * Concise, Destructive, Left Leaning Red Black Tree implementation.\r\n * See: https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\r\n * See: https://en.wikipedia.org/wiki/Left-leaning_red%E2%80%93black_tree\r\n * See: http://www.teachsolaisgames.com/articles/balanced_left_leaning.html\r\n */\r\nvar Color;\r\n(function (Color) {\r\n    Color[Color[\"BLACK\"] = 0] = \"BLACK\";\r\n    Color[Color[\"RED\"] = 1] = \"RED\";\r\n})(Color || (Color = {}));\r\nvar Dir;\r\n(function (Dir) {\r\n    Dir[Dir[\"LEFT\"] = 0] = \"LEFT\";\r\n    Dir[Dir[\"RIGHT\"] = 1] = \"RIGHT\";\r\n})(Dir || (Dir = {}));\r\n/**\r\n * Red Black Tree node.\r\n * @constructor\r\n * @param {*} data\r\n */\r\nvar Node = /** @class */ (function () {\r\n    function Node(data, asArray) {\r\n        if (asArray) {\r\n            this.data = [data];\r\n        }\r\n        else {\r\n            this.data = data;\r\n        }\r\n        this.color = Color.RED;\r\n    }\r\n    return Node;\r\n}());\r\nfunction isRed(node) {\r\n    return node && node.color === Color.RED;\r\n}\r\n/**\r\n * @param compare\r\n * @param datas\r\n * @param replaceDups - If true then if a duplicate is\r\n * inserted (as per the equivalence relation induced by the compare)\r\n * then replace it. If false then keep an array of values at the relevant\r\n * node.\r\n */\r\nvar LlRbTree = /** @class */ (function () {\r\n    function LlRbTree(compare, datas, replaceDups) {\r\n        this.getMinNode = this.getMinOrMaxNode(Dir.LEFT);\r\n        this.getMaxNode = this.getMinOrMaxNode(Dir.RIGHT);\r\n        var tree = this;\r\n        tree.setComparator(compare, replaceDups);\r\n        tree.replaceDups = replaceDups;\r\n        tree.root = null;\r\n        if (!datas) {\r\n            return;\r\n        }\r\n        for (var _i = 0, datas_1 = datas; _i < datas_1.length; _i++) {\r\n            var data = datas_1[_i];\r\n            tree.insert(data);\r\n        }\r\n    }\r\n    /**\r\n     * Destructively sets the tree compare. This function can be used for for e.g.\r\n     * the Bentley Ottmann algorithm.\r\n     */\r\n    LlRbTree.prototype.setComparator = function (compare, replaceDups) {\r\n        if (replaceDups) {\r\n            this.compare = compare;\r\n        }\r\n        else {\r\n            this.compare = function (a, b) { return compare(a, b[0]); };\r\n        }\r\n    };\r\n    LlRbTree.prototype.isEmpty = function () { return !this.root; };\r\n    /**\r\n     * Find the node in the tree with the given data using the tree compare\r\n     * function.\r\n     * @returns {Node} node or null if not found.\r\n     */\r\n    LlRbTree.prototype.find = function (data) {\r\n        var tree = this;\r\n        var node = this.root;\r\n        while (node) {\r\n            var c = tree.compare(data, node.data);\r\n            if (c === 0) {\r\n                return node;\r\n            }\r\n            else {\r\n                node = node[c > 0 ? Dir.RIGHT : Dir.LEFT];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * .\r\n     */\r\n    LlRbTree.prototype.toArrayInOrder = function () {\r\n        var nodes = [];\r\n        f(this.root);\r\n        function f(node) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            f(node[Dir.LEFT]);\r\n            nodes.push(node);\r\n            f(node[Dir.RIGHT]);\r\n        }\r\n        return nodes;\r\n    };\r\n    /**\r\n     * Inserts a node with the given data into the tree.\r\n     */\r\n    LlRbTree.prototype.insert = function (data) {\r\n        var tree = this;\r\n        tree.root = f(tree.root, data);\r\n        tree.root.color = Color.BLACK;\r\n        tree.root.parent = undefined;\r\n        function f(h, data) {\r\n            if (!h) {\r\n                return new Node(data, !tree.replaceDups);\r\n            }\r\n            var c = tree.compare(data, h.data);\r\n            if (c === 0) {\r\n                if (tree.replaceDups) {\r\n                    h.data = data;\r\n                }\r\n                else {\r\n                    h.data.push(data);\r\n                }\r\n            }\r\n            else {\r\n                var dir = c > 0 ? Dir.RIGHT : Dir.LEFT;\r\n                h[dir] = f(h[dir], data);\r\n                h[dir].parent = h;\r\n            }\r\n            if (isRed(h[Dir.RIGHT]) &&\r\n                !isRed(h[Dir.LEFT])) {\r\n                h = rotate(Dir.LEFT, h);\r\n            }\r\n            if (isRed(h[Dir.LEFT]) &&\r\n                isRed(h[Dir.LEFT][Dir.LEFT])) {\r\n                h = rotate(Dir.RIGHT, h);\r\n            }\r\n            if (isRed(h[Dir.LEFT]) &&\r\n                isRed(h[Dir.RIGHT])) {\r\n                flipColors(h);\r\n            }\r\n            return h;\r\n        }\r\n    };\r\n    /**\r\n     * Removes an item from the tree based on the given data.\r\n     * @param {LlRbTree} tree\r\n     * @param {*} data\r\n     * @param {boolean} all - If the data is an array, remove all.\r\n     */\r\n    LlRbTree.prototype.remove = function (data, all) {\r\n        var tree = this;\r\n        tree.root = f(tree.root, data);\r\n        if (tree.root) {\r\n            tree.root.color = Color.BLACK;\r\n            tree.root.parent = undefined;\r\n        }\r\n        function f(h, data) {\r\n            //let h = h_;\r\n            var c = tree.compare(data, h.data);\r\n            if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                removeFromArray(data, h.data);\r\n                return h;\r\n            }\r\n            if (c < 0 && !h[Dir.LEFT] || c > 0 && !h[Dir.RIGHT]) {\r\n                return h;\r\n            }\r\n            if (c < 0) {\r\n                if (!isRed(h[Dir.LEFT]) &&\r\n                    !isRed(h[Dir.LEFT][Dir.LEFT])) {\r\n                    h = moveRedLeft(h);\r\n                }\r\n                h[Dir.LEFT] = f(h[Dir.LEFT], data);\r\n                if (h[Dir.LEFT]) {\r\n                    h[Dir.LEFT].parent = h;\r\n                }\r\n                return fixUp(h);\r\n            }\r\n            if (isRed(h[Dir.LEFT])) {\r\n                h = rotate(Dir.RIGHT, h);\r\n                c = tree.compare(data, h.data);\r\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                    removeFromArray(data, h.data);\r\n                    return h;\r\n                }\r\n            }\r\n            if (c === 0 && !h[Dir.RIGHT]) {\r\n                return null;\r\n            }\r\n            if (!isRed(h[Dir.RIGHT]) &&\r\n                !isRed(h[Dir.RIGHT][Dir.LEFT])) {\r\n                h = moveRedRight(h);\r\n                c = tree.compare(data, h.data);\r\n                if (!tree.replaceDups && c === 0 && !all && h.data.length > 1) {\r\n                    removeFromArray(data, h.data);\r\n                    return h;\r\n                }\r\n            }\r\n            if (c === 0) {\r\n                h.data = tree.min(h[Dir.RIGHT]);\r\n                h[Dir.RIGHT] = removeMin(h[Dir.RIGHT]);\r\n            }\r\n            else {\r\n                h[Dir.RIGHT] = f(h[Dir.RIGHT], data);\r\n            }\r\n            if (h[Dir.RIGHT]) {\r\n                h[Dir.RIGHT].parent = h;\r\n            }\r\n            return fixUp(h);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the two ordered nodes bounding the data. If the\r\n     * data falls on a node, that node and the next (to the right) is\r\n     * returned.\r\n     * @returns {Node[]}\r\n     */\r\n    LlRbTree.prototype.findBounds = function (data) {\r\n        var tree = this;\r\n        var node = tree.root;\r\n        var bounds = [undefined, undefined];\r\n        if (node === null) {\r\n            return bounds;\r\n        }\r\n        while (node) {\r\n            var c = tree.compare(data, node.data);\r\n            if (c >= 0) {\r\n                bounds[0] = node;\r\n            }\r\n            else {\r\n                bounds[1] = node;\r\n            }\r\n            node = node[c >= 0 ? Dir.RIGHT : Dir.LEFT];\r\n        }\r\n        return bounds;\r\n    };\r\n    /**\r\n     * @param {LlRbTree} tree\r\n     * @param {*} data\r\n     * @returns {Node[]} The two ordered nodes bounding the data. If the\r\n     * data falls on a node, returns the nodes before and after this one.\r\n     */\r\n    LlRbTree.prototype.findBoundsExcl = function (data) {\r\n        var tree = this;\r\n        var node = tree.root;\r\n        var bounds = [undefined, undefined];\r\n        if (node === null) {\r\n            return bounds;\r\n        }\r\n        f(node);\r\n        function f(node) {\r\n            while (node) {\r\n                var c = tree.compare(data, node.data);\r\n                if (c === 0) {\r\n                    // Search on both sides\r\n                    f(node[Dir.LEFT]);\r\n                    f(node[Dir.RIGHT]);\r\n                    return;\r\n                }\r\n                if (c > 0) {\r\n                    bounds[0] = node;\r\n                }\r\n                else if (c < 0) {\r\n                    bounds[1] = node;\r\n                }\r\n                node = node[c > 0 ? Dir.RIGHT : Dir.LEFT];\r\n            }\r\n        }\r\n        return bounds;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    LlRbTree.prototype.findAllInOrder = function (data) {\r\n        var tree = this;\r\n        var nodes = [];\r\n        f(tree.root);\r\n        function f(node) {\r\n            while (node) {\r\n                var c = tree.compare(data, node.data);\r\n                if (c === 0) {\r\n                    f(node[Dir.LEFT]);\r\n                    nodes.push(node);\r\n                    f(node[Dir.RIGHT]);\r\n                    return;\r\n                }\r\n                node = node[c > 0 ? Dir.RIGHT : Dir.LEFT];\r\n            }\r\n        }\r\n        return nodes;\r\n    };\r\n    LlRbTree.prototype.getMinOrMaxNode = function (dir) {\r\n        return function (node) {\r\n            if (!node) {\r\n                return undefined;\r\n            }\r\n            while (node[dir]) {\r\n                node = node[dir];\r\n            }\r\n            return node;\r\n        };\r\n    };\r\n    LlRbTree.prototype.min = function (node) {\r\n        return this.getMinNode(node).data;\r\n    };\r\n    LlRbTree.prototype.max = function (node) {\r\n        return this.getMaxNode(node).data;\r\n    };\r\n    return LlRbTree;\r\n}());\r\n/**\r\n * Removes the data from the tuple using ===.\r\n * Note this function uses === and not the compare function!\r\n */\r\nfunction removeFromArray(elem, arr) {\r\n    var index = arr.indexOf(elem);\r\n    if (index !== -1) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n/**\r\n * Destructively rotates the given node, say h, in the\r\n * given direction as far as tree rotations go.\r\n * @param {boolean} dir true -> right, false -> left\r\n * @param {Node} h\r\n * @returns The node that is at the top after the rotation.\r\n */\r\nfunction rotate(dir, h) {\r\n    var otherDir = dir ? Dir.LEFT : Dir.RIGHT;\r\n    var x = h[otherDir];\r\n    h[otherDir] = x[dir];\r\n    if (x[dir]) {\r\n        x[dir].parent = h;\r\n    }\r\n    x[dir] = h;\r\n    h.parent = x;\r\n    x.color = h.color;\r\n    h.color = Color.RED;\r\n    return x;\r\n}\r\nfunction removeMin(h) {\r\n    if (!h[Dir.LEFT]) {\r\n        return null;\r\n    }\r\n    if (!isRed(h[Dir.LEFT]) &&\r\n        !isRed(h[Dir.LEFT][Dir.LEFT])) {\r\n        h = moveRedLeft(h);\r\n    }\r\n    h[Dir.LEFT] = removeMin(h[Dir.LEFT]);\r\n    if (h[Dir.LEFT]) {\r\n        h[Dir.LEFT].parent = h;\r\n    }\r\n    return fixUp(h);\r\n}\r\nfunction flipColor(color) {\r\n    return color === Color.RED ? Color.BLACK : Color.RED;\r\n}\r\n/**\r\n * Destructively flips the color of the given node and both\r\n * it's childrens' colors.\r\n * @param {Node} h\r\n */\r\nfunction flipColors(h) {\r\n    h.color = flipColor(h.color);\r\n    h[Dir.LEFT].color = flipColor(h[Dir.LEFT].color);\r\n    h[Dir.RIGHT].color = flipColor(h[Dir.RIGHT].color);\r\n}\r\n/**\r\n * @description\r\n * @param h\r\n * @returns The node that is at the top after the move.\r\n */\r\nfunction moveRedLeft(h) {\r\n    flipColors(h);\r\n    if (isRed(h[Dir.RIGHT][Dir.LEFT])) {\r\n        var a = rotate(Dir.RIGHT, h[Dir.RIGHT]);\r\n        h[Dir.RIGHT] = a;\r\n        a.parent = h;\r\n        h = rotate(Dir.LEFT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * @description\r\n * @param h\r\n * @returns The node that is at the top after the move.\r\n */\r\nfunction moveRedRight(h) {\r\n    flipColors(h);\r\n    if (isRed(h[Dir.LEFT][Dir.LEFT])) {\r\n        h = rotate(Dir.RIGHT, h);\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\n/**\r\n * @description Fix right-leaning red nodes.\r\n * @returns The node that is at the top after the fix.\r\n */\r\nfunction fixUp(h) {\r\n    if (isRed(h[Dir.RIGHT])) {\r\n        h = rotate(Dir.LEFT, h);\r\n    }\r\n    if (isRed(h[Dir.LEFT]) &&\r\n        isRed(h[Dir.LEFT][Dir.LEFT])) {\r\n        h = rotate(Dir.RIGHT, h);\r\n    }\r\n    // Split 4-nodes.\r\n    if (isRed(h[Dir.LEFT]) &&\r\n        isRed(h[Dir.RIGHT])) {\r\n        flipColors(h);\r\n    }\r\n    return h;\r\n}\r\nmodule.exports = LlRbTree;\r\n\n},{}]},{},[1])(1)\n});"]}