var t={d:(o,r)=>{for(var e in r)t.o(r,e)&&!t.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:r[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)},o={};t.d(o,{E5:()=>n,RL:()=>r,dn:()=>a,NB:()=>s,hM:()=>i,pX:()=>e,xC:()=>u,iK:()=>p,Wl:()=>h,Qx:()=>m});const r=-1,e=1,n=1,i=0;class s{constructor(t){this.datum=t,this.color=i}}function u(t){return!!t&&t.color===i}class a{constructor(t,o=!0,n){if(this.compare=t,this.duplicatesAllowed=o,this.getMinNode=this.getMinOrMaxNode(r),this.getMaxNode=this.getMinOrMaxNode(e),this.root=void 0,this.nodeCount=0,this.valueCount=0,n)for(const t of n)this.insert(t)}isEmpty(){return!this.root}find(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return n;n=n[i>0?e:r]}}toArrayInOrder(){const t=[];return function o(n){n&&(o(n[r]),t.push(n.datum),void 0!==n.extras&&t.push(...n.extras),o(n[e]))}(this.root),t}insertMulti(t){const o=this;for(let r of t)o.insert(r)}insert(t){const o=this;o.root=function t(n,i){if(void 0===n)return o.valueCount++,o.nodeCount++,new s(i);let a=o.compare(i,n.datum);if(0===a&&(o.duplicatesAllowed?(o.valueCount++,void 0===n.extras?n.extras=[i]:n.extras.push(i)):n.datum=i),0!==a){const o=a>0?e:r;n[o]=t(n[o],i),n[o].parent=n}return u(n[e])&&!u(n[r])&&(n=d(r,n)),u(n[r])&&u(n[r][r])&&(n=d(e,n)),u(n[r])&&u(n[e])&&l(n),n}(o.root,t),o.root.color=n,o.root.parent=void 0}remove(t,o=!0){const i=this;if(void 0===i.root)return!1;let s=!1;return i.root=function t(n,a){let p=i.compare(a,n.datum);if(p<0&&!n[r]||p>0&&!n[e])return n;if(p<0)return u(n[r])||u(n[r][r])||(n=f(n)),n[r]=t(n[r],a),n[r]&&(n[r].parent=n),v(n);if(u(n[r])&&(n=d(e,n),p=i.compare(a,n.datum)),0===p&&!n[e])return i.duplicatesAllowed&&!o&&void 0!==n.extras?(n.extras.pop(),s=!0,i.valueCount--,0===n.extras.length&&(n.extras=void 0),n):(s=!0,i.nodeCount--,void i.valueCount--);if(u(n[e])||u(n[e][r])||(n=function(t){return l(t),u(t[r][r])&&l(t=d(e,t)),t}(n),p=i.compare(a,n.datum)),0===p)if(i.duplicatesAllowed)if(s=!0,i.valueCount--,o||void 0===n.extras){const t=i.getMinNode(n[e]);n.datum=t?.datum,n.extras=t?.extras,n[e]=c(n[e]),i.nodeCount--}else n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n[e]=t(n[e],a);else n.datum=i.getMinNode(n[e])?.datum,n[e]=c(n[e]),i.nodeCount--;else n[e]=t(n[e],a);return n[e]&&(n[e].parent=n),v(n)}(i.root,t),i.root&&(i.root.color=n,i.root.parent=void 0),s}findBounds(t){const o=this;let n=o.root;const i=[void 0,void 0];if(void 0===n)return i;for(;n;){const s=o.compare(t,n.datum);s>=0?i[0]=n:i[1]=n,n=n[s>=0?e:r]}return i}findBoundsExcl(t){const o=this,n=o.root,i=[void 0,void 0];return void 0===n||function n(s){for(;s;){const u=o.compare(t,s.datum);if(0===u)return n(s[r]),void n(s[e]);u>0?i[0]=s:u<0&&(i[1]=s),s=s[u>0?e:r]}}(n),i}findAll(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return[n.datum,...n.extras?n.extras:[]];n=n[i>0?e:r]}return[]}getMinOrMaxNode(t){return o=>{if(void 0===o&&(o=this.root),o){for(;o[t];)o=o[t];return o}}}min(t){void 0===t&&(t=this.root);const o=this.getMinNode(t);if(void 0!==o)return o.datum}max(t){void 0===t&&(t=this.root);const o=this.getMaxNode(t);if(void 0!==o)return o.datum}}function d(t,o){const r=o[-t];return o[-t]=r[t],r[t]&&(r[t].parent=o),r[t]=o,o.parent=r,r.color=o.color,o.color=i,r}function c(t){if(t[r])return u(t[r])||u(t[r][r])||(t=f(t)),t[r]=c(t[r]),t[r]&&(t[r].parent=t),v(t)}function l(t){t.color=(t.color+1)%2,t[r].color=(t[r].color+1)%2,t[e].color=(t[e].color+1)%2}function f(t){if(l(t),u(t[e][r])){const o=d(e,t[e]);t[e]=o,o.parent=t,l(t=d(r,t))}return t}function v(t){return u(t[e])&&(t=d(r,t)),u(t[r])&&u(t[r][r])&&(t=d(e,t)),u(t[r])&&u(t[e])&&l(t),t}function p(t){return o=>{let r;return r=void 0!==o.extras?`{${[o.datum,...o.extras].map(t)}}`:t(o.datum),r+(u(o)?"•":"·")}}const h=p((t=>t.toString()));function m(t){return o=>{const n=o.root;let i="";return function o(n){void 0!==n&&(i+=t(n),(void 0!==n[r]||null!=n[e])&&(void 0!==n[r]&&(i+="(",o(n[r]),i+=")"),void 0!==n[e]&&(i+="[",o(n[e]),i+="]")))}(n),i}}var x=o.E5,M=o.RL,C=o.dn,g=o.NB,N=o.hM,A=o.pX,O=o.xC,w=o.iK,E=o.Wl,R=o.Qx;export{x as BLACK,M as LEFT,C as LlRbTree,g as Node,N as RED,A as RIGHT,O as isRed,w as nodeToStr,E as numberNodeToStr,R as treeToStr};