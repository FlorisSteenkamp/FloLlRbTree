var t={d:(o,r)=>{for(var e in r)t.o(r,e)&&!t.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:r[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)},o={};t.d(o,{dn:()=>d,NB:()=>s,RL:()=>r,pX:()=>e,hM:()=>i,E5:()=>n,xC:()=>a});const r=-1,e=1,n=1,i=0;class s{constructor(t){this.datum=t,this.color=i}}function a(t){return!!t&&t.color===i}class d{constructor(t,o=!0,n){if(this.compare=t,this.duplicatesAllowed=o,this.getMinNode=this.getMinOrMaxNode(r),this.getMaxNode=this.getMinOrMaxNode(e),this.root=void 0,n)for(const t of n)this.insert(t)}isEmpty(){return!this.root}find(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return n;n=n[i>0?e:r]}}toArrayInOrder(){const t=[];return function o(n){n&&(o(n[r]),t.push(n.datum),void 0!==n.extras&&t.push(...n.extras),o(n[e]))}(this.root),t}insertMulti(t){const o=this;for(let r of t)o.insert(r)}insert(t){const o=this;o.root=function t(n,i){if(void 0===n)return new s(i);let d=o.compare(i,n.datum);if(0===d&&(o.duplicatesAllowed?void 0===n.extras?n.extras=[i]:n.extras.push(i):n.datum=i),0!==d){const o=d>0?e:r;n[o]=t(n[o],i),n[o].parent=n}return a(n[e])&&!a(n[r])&&(n=c(r,n)),a(n[r])&&a(n[r][r])&&(n=c(e,n)),a(n[r])&&a(n[e])&&l(n),n}(o.root,t),o.root.color=n,o.root.parent=void 0}remove(t,o=!0){const i=this;void 0!==i.root&&(i.root=function t(n,s){let d=i.compare(s,n.datum);if(d<0&&!n[r]||d>0&&!n[e])return n;if(d<0)return a(n[r])||a(n[r][r])||(n=f(n)),n[r]=t(n[r],s),n[r]&&(n[r].parent=n),p(n);if(a(n[r])&&(n=c(e,n),d=i.compare(s,n.datum)),0===d&&!n[e])return i.duplicatesAllowed&&!o&&void 0!==n.extras?(n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n):void 0;if(a(n[e])||a(n[e][r])||(n=function(t){return l(t),a(t[r][r])&&l(t=c(e,t)),t}(n),d=i.compare(s,n.datum)),0===d)if(i.duplicatesAllowed)if(o||void 0===n.extras){const t=i.getMinNode(n[e]);n.datum=t?.datum,n.extras=t?.extras,n[e]=u(n[e])}else n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n[e]=t(n[e],s);else n.datum=i.getMinNode(n[e])?.datum,n[e]=u(n[e]);else n[e]=t(n[e],s);return n[e]&&(n[e].parent=n),p(n)}(i.root,t),i.root&&(i.root.color=n,i.root.parent=void 0))}findBounds(t){const o=this;let n=o.root;const i=[void 0,void 0];if(void 0===n)return i;for(;n;){const s=o.compare(t,n.datum);s>=0?i[0]=n:i[1]=n,n=n[s>=0?e:r]}return i}findBoundsExcl(t){const o=this,n=o.root,i=[void 0,void 0];return void 0===n||function n(s){for(;s;){const a=o.compare(t,s.datum);if(0===a)return n(s[r]),void n(s[e]);a>0?i[0]=s:a<0&&(i[1]=s),s=s[a>0?e:r]}}(n),i}findAll(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return[n.datum,...n.extras?n.extras:[]];n=n[i>0?e:r]}return[]}getMinOrMaxNode(t){return o=>{if(void 0===o&&(o=this.root),o){for(;o[t];)o=o[t];return o}}}min(t){void 0===t&&(t=this.root);const o=this.getMinNode(t);if(void 0!==o)return o.datum}max(t){void 0===t&&(t=this.root);const o=this.getMaxNode(t);if(void 0!==o)return o.datum}}function c(t,o){const r=o[-t];return o[-t]=r[t],r[t]&&(r[t].parent=o),r[t]=o,o.parent=r,r.color=o.color,o.color=i,r}function u(t){if(t[r])return a(t[r])||a(t[r][r])||(t=f(t)),t[r]=u(t[r]),t[r]&&(t[r].parent=t),p(t)}function l(t){t.color=(t.color+1)%2,t[r].color=(t[r].color+1)%2,t[e].color=(t[e].color+1)%2}function f(t){if(l(t),a(t[e][r])){const o=c(e,t[e]);t[e]=o,o.parent=t,l(t=c(r,t))}return t}function p(t){return a(t[e])&&(t=c(r,t)),a(t[r])&&a(t[r][r])&&(t=c(e,t)),a(t[r])&&a(t[e])&&l(t),t}var h=o.E5,m=o.RL,v=o.dn,x=o.NB,M=o.hM,g=o.pX,N=o.xC;export{h as BLACK,m as LEFT,v as LlRbTree,x as Node,M as RED,g as RIGHT,N as isRed};