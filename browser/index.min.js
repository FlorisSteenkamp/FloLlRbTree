var FloLlRbTree;(()=>{"use strict";var t={d:(o,r)=>{for(var e in r)t.o(r,e)&&!t.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:r[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},o={};t.r(o),t.d(o,{LlRbTree:()=>a,Node:()=>s,LEFT:()=>r,RIGHT:()=>e,RED:()=>i,BLACK:()=>n,isRed:()=>d});const r=-1,e=1,n=1,i=0;class s{constructor(t){this.datum=t,this.color=i}}function d(t){return!!t&&t.color===i}class a{constructor(t,o=!0,n){if(this.compare=t,this.duplicatesAllowed=o,this.getMinNode=this.getMinOrMaxNode(r),this.getMaxNode=this.getMinOrMaxNode(e),this.root=void 0,n)for(const t of n)this.insert(t)}isEmpty(){return!this.root}find(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return n;n=n[i>0?e:r]}}toArrayInOrder(){const t=[];return function o(n){n&&(o(n[r]),t.push(n.datum),void 0!==n.extras&&t.push(...n.extras),o(n[e]))}(this.root),t}insertMulti(t){const o=this;for(let r of t)o.insert(r)}insert(t){const o=this;o.root=function t(n,i){if(void 0===n)return new s(i);let a=o.compare(i,n.datum);if(0===a&&(o.duplicatesAllowed?void 0===n.extras?n.extras=[i]:n.extras.push(i):n.datum=i),0!==a){const o=a>0?e:r;n[o]=t(n[o],i),n[o].parent=n}return d(n[e])&&!d(n[r])&&(n=u(r,n)),d(n[r])&&d(n[r][r])&&(n=u(e,n)),d(n[r])&&d(n[e])&&l(n),n}(o.root,t),o.root.color=n,o.root.parent=void 0}remove(t,o=!0){const i=this;void 0!==i.root&&(i.root=function t(n,s){let a=i.compare(s,n.datum);if(a<0&&!n[r]||a>0&&!n[e])return n;if(a<0)return d(n[r])||d(n[r][r])||(n=f(n)),n[r]=t(n[r],s),n[r]&&(n[r].parent=n),p(n);if(d(n[r])&&(n=u(e,n),a=i.compare(s,n.datum)),0===a&&!n[e])return i.duplicatesAllowed&&!o&&void 0!==n.extras?(n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n):void 0;if(d(n[e])||d(n[e][r])||(n=function(t){return l(t),d(t[r][r])&&l(t=u(e,t)),t}(n),a=i.compare(s,n.datum)),0===a)if(i.duplicatesAllowed)if(o||void 0===n.extras){const t=i.getMinNode(n[e]);n.datum=t?.datum,n.extras=t?.extras,n[e]=c(n[e])}else n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n[e]=t(n[e],s);else n.datum=i.getMinNode(n[e])?.datum,n[e]=c(n[e]);else n[e]=t(n[e],s);return n[e]&&(n[e].parent=n),p(n)}(i.root,t),i.root&&(i.root.color=n,i.root.parent=void 0))}findBounds(t){const o=this;let n=o.root;const i=[void 0,void 0];if(void 0===n)return i;for(;n;){const s=o.compare(t,n.datum);s>=0?i[0]=n:i[1]=n,n=n[s>=0?e:r]}return i}findBoundsExcl(t){const o=this,n=o.root,i=[void 0,void 0];return void 0===n||function n(s){for(;s;){const d=o.compare(t,s.datum);if(0===d)return n(s[r]),void n(s[e]);d>0?i[0]=s:d<0&&(i[1]=s),s=s[d>0?e:r]}}(n),i}findAll(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return[n.datum,...n.extras?n.extras:[]];n=n[i>0?e:r]}return[]}getMinOrMaxNode(t){return o=>{if(void 0===o&&(o=this.root),o){for(;o[t];)o=o[t];return o}}}min(t){void 0===t&&(t=this.root);const o=this.getMinNode(t);if(void 0!==o)return o.datum}max(t){void 0===t&&(t=this.root);const o=this.getMaxNode(t);if(void 0!==o)return o.datum}}function u(t,o){const r=o[-t];return o[-t]=r[t],r[t]&&(r[t].parent=o),r[t]=o,o.parent=r,r.color=o.color,o.color=i,r}function c(t){if(t[r])return d(t[r])||d(t[r][r])||(t=f(t)),t[r]=c(t[r]),t[r]&&(t[r].parent=t),p(t)}function l(t){t.color=(t.color+1)%2,t[r].color=(t[r].color+1)%2,t[e].color=(t[e].color+1)%2}function f(t){if(l(t),d(t[e][r])){const o=u(e,t[e]);t[e]=o,o.parent=t,l(t=u(r,t))}return t}function p(t){return d(t[e])&&(t=u(r,t)),d(t[r])&&d(t[r][r])&&(t=u(e,t)),d(t[r])&&d(t[e])&&l(t),t}FloLlRbTree=o})();