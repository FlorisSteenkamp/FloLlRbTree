var FloLlRbTree;(()=>{"use strict";var t={d:(o,r)=>{for(var e in r)t.o(r,e)&&!t.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:r[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},o={};t.r(o),t.d(o,{BLACK:()=>n,LEFT:()=>r,LlRbTree:()=>d,Node:()=>u,RED:()=>i,RIGHT:()=>e,isRed:()=>s,nodeToStr:()=>m,numberNodeToStr:()=>p,treeToStr:()=>h});const r=-1,e=1,n=1,i=0;class u{constructor(t){this.datum=t,this.color=i}}function s(t){return!!t&&t.color===i}class d{constructor(t,o=!0,n){if(this.compare=t,this.duplicatesAllowed=o,this.getMinNode=this.getMinOrMaxNode(r),this.getMaxNode=this.getMinOrMaxNode(e),this.root=void 0,this.nodeCount=0,this.valueCount=0,n)for(const t of n)this.insert(t)}isEmpty(){return!this.root}find(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return n;n=n[i>0?e:r]}}toArrayInOrder(){const t=[];return function o(n){n&&(o(n[r]),t.push(n.datum),void 0!==n.extras&&t.push(...n.extras),o(n[e]))}(this.root),t}insertMulti(t){const o=this;for(let r of t)o.insert(r)}insert(t){const o=this;o.root=function t(n,i){if(void 0===n)return o.valueCount++,o.nodeCount++,new u(i);let d=o.compare(i,n.datum);if(0===d&&(o.duplicatesAllowed?(o.valueCount++,void 0===n.extras?n.extras=[i]:n.extras.push(i)):n.datum=i),0!==d){const o=d>0?e:r;n[o]=t(n[o],i),n[o].parent=n}return s(n[e])&&!s(n[r])&&(n=a(r,n)),s(n[r])&&s(n[r][r])&&(n=a(e,n)),s(n[r])&&s(n[e])&&l(n),n}(o.root,t),o.root.color=n,o.root.parent=void 0}remove(t,o=!0){const i=this;if(void 0===i.root)return!1;let u=!1;return i.root=function t(n,d){let m=i.compare(d,n.datum);if(m<0&&!n[r]||m>0&&!n[e])return n;if(m<0)return s(n[r])||s(n[r][r])||(n=f(n)),n[r]=t(n[r],d),n[r]&&(n[r].parent=n),v(n);if(s(n[r])&&(n=a(e,n),m=i.compare(d,n.datum)),0===m&&!n[e])return i.duplicatesAllowed&&!o&&void 0!==n.extras?(n.extras.pop(),u=!0,i.valueCount--,0===n.extras.length&&(n.extras=void 0),n):(u=!0,i.nodeCount--,void i.valueCount--);if(s(n[e])||s(n[e][r])||(n=function(t){return l(t),s(t[r][r])&&l(t=a(e,t)),t}(n),m=i.compare(d,n.datum)),0===m)if(i.duplicatesAllowed)if(u=!0,i.valueCount--,o||void 0===n.extras){const t=i.getMinNode(n[e]);n.datum=t?.datum,n.extras=t?.extras,n[e]=c(n[e]),i.nodeCount--}else n.extras.pop(),0===n.extras.length&&(n.extras=void 0),n[e]=t(n[e],d);else n.datum=i.getMinNode(n[e])?.datum,n[e]=c(n[e]),i.nodeCount--;else n[e]=t(n[e],d);return n[e]&&(n[e].parent=n),v(n)}(i.root,t),i.root&&(i.root.color=n,i.root.parent=void 0),u}findBounds(t){const o=this;let n=o.root;const i=[void 0,void 0];if(void 0===n)return i;for(;n;){const u=o.compare(t,n.datum);u>=0?i[0]=n:i[1]=n,n=n[u>=0?e:r]}return i}findBoundsExcl(t){const o=this,n=o.root,i=[void 0,void 0];return void 0===n||function n(u){for(;u;){const s=o.compare(t,u.datum);if(0===s)return n(u[r]),void n(u[e]);s>0?i[0]=u:s<0&&(i[1]=u),u=u[s>0?e:r]}}(n),i}findAll(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return[n.datum,...n.extras?n.extras:[]];n=n[i>0?e:r]}return[]}getMinOrMaxNode(t){return o=>{if(void 0===o&&(o=this.root),o){for(;o[t];)o=o[t];return o}}}min(t){void 0===t&&(t=this.root);const o=this.getMinNode(t);if(void 0!==o)return o.datum}max(t){void 0===t&&(t=this.root);const o=this.getMaxNode(t);if(void 0!==o)return o.datum}}function a(t,o){const r=o[-t];return o[-t]=r[t],r[t]&&(r[t].parent=o),r[t]=o,o.parent=r,r.color=o.color,o.color=i,r}function c(t){if(t[r])return s(t[r])||s(t[r][r])||(t=f(t)),t[r]=c(t[r]),t[r]&&(t[r].parent=t),v(t)}function l(t){t.color=(t.color+1)%2,t[r].color=(t[r].color+1)%2,t[e].color=(t[e].color+1)%2}function f(t){if(l(t),s(t[e][r])){const o=a(e,t[e]);t[e]=o,o.parent=t,l(t=a(r,t))}return t}function v(t){return s(t[e])&&(t=a(r,t)),s(t[r])&&s(t[r][r])&&(t=a(e,t)),s(t[r])&&s(t[e])&&l(t),t}function m(t){return o=>{let r;return r=void 0!==o.extras?`{${[o.datum,...o.extras].map(t)}}`:t(o.datum),r+(s(o)?"•":"·")}}const p=m((t=>t.toString()));function h(t){return o=>{const n=o.root;let i="";return function o(n){void 0!==n&&(i+=t(n),(void 0!==n[r]||null!=n[e])&&(void 0!==n[r]&&(i+="(",o(n[r]),i+=")"),void 0!==n[e]&&(i+="[",o(n[e]),i+="]")))}(n),i}}FloLlRbTree=o})();